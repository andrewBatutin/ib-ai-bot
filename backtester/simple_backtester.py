# backtester/simple_backtester.py

import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt # Ensure pyplot is imported
import logging # Add logging import
import matplotlib.dates as mdates
from .strategies import generate_average_volatility_signals, generate_bollinger_bands_signals # Assuming strategies.py is in the same directory
from mlfinpy.data_structure import get_volume_bars # Added for volume bars

def _calculate_volume_bar_threshold(data_df: pd.DataFrame, target_bars_per_day: int, volume_col: str = 'Volume') -> float:
    """
    Estimates the volume threshold for generating volume bars aiming for a
    target number of bars per trading day.
    Internal helper function.

    Args:
        data_df (pd.DataFrame): DataFrame containing tick or high-frequency data.
                                 Must have a DatetimeIndex and a volume column.
        target_bars_per_day (int): The desired average number of volume bars per trading day.
        volume_col (str): The name of the column containing volume data. Defaults to 'Volume'.

    Returns:
        float: The estimated volume threshold. Returns np.nan if calculation fails.
    """
    if not isinstance(data_df.index, pd.DatetimeIndex):
        try:
            # Attempt conversion if not already datetime
            data_df_temp = data_df.copy()
            data_df_temp.index = pd.to_datetime(data_df_temp.index)
        except Exception as e:
            print(f"Error converting index to DatetimeIndex: {e}")
            return np.nan
    else:
        data_df_temp = data_df # Use directly if already datetime

    if data_df_temp.empty:
        print("Error: Input DataFrame is empty for threshold calculation.")
        return np.nan

    if volume_col not in data_df_temp.columns:
        print(f"Error: Volume column '{volume_col}' not found in DataFrame.")
        return np.nan

    # Calculate number of unique trading days
    num_trading_days = data_df_temp.index.normalize().nunique()

    if num_trading_days == 0:
        print("Error: Could not determine the number of trading days from the index.")
        return np.nan

    # Calculate Total Volume
    total_volume = data_df_temp[volume_col].sum()

    if total_volume <= 0:
        # Allow zero volume if there are days, maybe no trades happened
        print("Warning: Total volume is zero or negative.")
        # Return a very large threshold if volume is zero, effectively creating few/no bars
        return np.inf if num_trading_days > 0 else np.nan

    # Calculate Average Daily Volume
    average_daily_volume = total_volume / num_trading_days

    # Calculate Threshold
    if target_bars_per_day <= 0:
        print("Error: target_bars_per_day must be positive.")
        return np.nan

    estimated_threshold = average_daily_volume / target_bars_per_day

    print(f"--- Volume Threshold Calculation ---")
    print(f"Num Trading Days: {num_trading_days}, Total Vol: {total_volume:,.0f}, Avg Daily Vol: {average_daily_volume:,.0f}")
    print(f"Target Bars/Day: {target_bars_per_day}, Estimated Threshold: {estimated_threshold:,.0f}")
    print(f"---------------------------------")

    return estimated_threshold

class SimpleBacktester:
    """
    A simple event-driven backtester for trading strategies.

    Attributes:
        data (pd.DataFrame): The raw input OHLCV data.
        initial_cash (float): The starting cash balance.
        commission_per_trade (float): The commission cost for each trade (buy or sell).
        bar_type (str): The type of bars to use ('time' or 'volume').
        volume_threshold (float | None): Explicit volume threshold for volume bars.
        target_bars_per_day (int | None): Target bars per day to calculate volume threshold.
        bars (pd.DataFrame | None): The generated bars (time or volume) used for the backtest.
        signals (pd.Series | None): The trading signals generated by the strategy.
        portfolio (pd.DataFrame): DataFrame tracking portfolio value, cash, holdings over time.
        trades (list): A list of dictionaries recording trade details.
    """

    def __init__(self, data: pd.DataFrame,
                 initial_cash: float = 100000.0,
                 commission_per_trade: float = 1.0,
                 bar_type: str = 'time',
                 volume_threshold: float | None = None,
                 target_bars_per_day: int | None = 50, # Default target if using volume bars without explicit threshold
                 volume_col: str = 'volume'):
        """
        Initializes the SimpleBacktester.

        Args:
            data (pd.DataFrame): DataFrame with OHLCV data. Must have a DatetimeIndex.
                                 For volume bars, needs a volume column (default 'Volume').
            initial_cash (float): Starting cash balance.
            commission_per_trade (float): Commission fee per transaction.
            bar_type (str): 'time' (default) or 'volume'. Determines bar generation.
            volume_threshold (float | None): If bar_type='volume', provide a specific threshold.
                                             If None, it's calculated using target_bars_per_day.
            target_bars_per_day (int | None): If bar_type='volume' and volume_threshold is None,
                                             this target is used to estimate the threshold.
            volume_col (str): Name of the volume column in the input data.
        """
        if not isinstance(data.index, pd.DatetimeIndex):
            try:
                data.index = pd.to_datetime(data.index)
            except Exception as e:
                raise ValueError(f"Failed to convert data index to DatetimeIndex: {e}")

        self.raw_data = data.copy() # Store raw data
        self.initial_cash = initial_cash
        self.commission_per_trade = commission_per_trade
        self.bar_type = bar_type.lower()
        self.volume_threshold = volume_threshold
        self.target_bars_per_day = target_bars_per_day
        self.volume_col = volume_col

        self.bars: pd.DataFrame | None = None # Generated bars (time or volume)
        self.signals: pd.Series | None = None # Generated signals
        self.portfolio: pd.DataFrame | None = None # Portfolio tracking
        self.trades = [] # List of trades

        if self.bar_type not in ['time', 'volume']:
            raise ValueError("bar_type must be either 'time' or 'volume'")

        if self.bar_type == 'volume' and self.volume_col not in self.raw_data.columns:
            raise ValueError(f"Volume column '{self.volume_col}' needed for volume bars not found in data.")

    def _generate_bars(self):
        """Generates the bars based on the specified bar_type."""
        if self.bars is not None:
            print("Bars already generated.")
            return # Avoid regenerating

        if self.bar_type == 'time':
            print("Using input data as time bars.")
            # Assume raw_data is already in the desired time frequency
            # Basic check for required columns
            required_cols = ['Open', 'High', 'Low', 'Close'] # Volume might not be needed for all time bar strats
            if not all(col in self.raw_data.columns for col in required_cols):
                 raise ValueError(f"Time bars require columns: {required_cols}")
            self.bars = self.raw_data.copy()
            # Ensure standard column names if they differ
            self.bars.rename(columns={'Open': 'open', 'High': 'high', 'Low': 'low', 'Close': 'close', self.volume_col: 'volume'}, inplace=True, errors='ignore')

        elif self.bar_type == 'volume':
            print("Generating volume bars...")
            threshold = self.volume_threshold
            if threshold is None:
                if self.target_bars_per_day is None:
                    raise ValueError("Must provide volume_threshold or target_bars_per_day for volume bars.")
                # Calculate threshold based on target bars per day
                threshold = _calculate_volume_bar_threshold(self.raw_data, self.target_bars_per_day, self.volume_col)
                if np.isnan(threshold) or np.isinf(threshold):
                    raise RuntimeError("Failed to calculate a valid volume threshold.")
                self.volume_threshold = threshold # Store calculated threshold

            if threshold <= 0:
                 raise ValueError("Volume threshold must be positive.")

            # Ensure input data has standard columns expected by mlfinpy if different
            # mlfinpy expects 'price' and 'volume' (lowercase)
            data_for_mlfinpy = self.raw_data.copy()
            if 'Close' in data_for_mlfinpy.columns and 'price' not in data_for_mlfinpy.columns:
                data_for_mlfinpy.rename(columns={'Close': 'price'}, inplace=True)
            if self.volume_col in data_for_mlfinpy.columns and 'volume' not in data_for_mlfinpy.columns:
                 data_for_mlfinpy.rename(columns={self.volume_col: 'volume'}, inplace=True)

            if 'price' not in data_for_mlfinpy.columns or 'volume' not in data_for_mlfinpy.columns:
                 raise ValueError("Data for mlfinpy needs 'price' (e.g., from Close) and 'volume' columns.")

            # Generate volume bars using mlfinpy
            # Note: get_volume_bars expects price & volume columns
            self.bars = get_volume_bars(data_for_mlfinpy, threshold=threshold, verbose=False)
            # mlfinpy outputs lowercase columns: open, high, low, close, volume

        else:
            raise ValueError(f"Unknown bar_type: {self.bar_type}")

        if self.bars is None or self.bars.empty:
            raise RuntimeError(f"Bar generation failed for type '{self.bar_type}'. Resulting bars DataFrame is empty or None.")
        print(f"Generated {len(self.bars)} {self.bar_type} bars.")

    def run_bollinger_bands(self, window: int = 20, num_std: float = 2.0):
        """
        Generates signals using the Bollinger Bands strategy.

        Args:
            window (int): Rolling window size for SMA and standard deviation.
            num_std (float): Number of standard deviations for the bands.

        Returns:
            pd.Series: The generated trading signals (1: Buy, -1: Sell, 0: Hold).
        """
        self._generate_bars() # Ensure bars are generated

        if self.bars is None or 'close' not in self.bars.columns:
             raise RuntimeError("Bars DataFrame is not generated or missing 'close' column.")

        print(f"Running Bollinger Bands strategy (window={window}, num_std={num_std}) on {self.bar_type} bars...")
        self.signals = generate_bollinger_bands_signals(
            price_series=self.bars['close'],
            window=window,
            num_std=num_std
        )
        # Align signals with bars index
        self.signals = self.signals.reindex(self.bars.index).fillna(0).astype(int)
        print("Bollinger Bands signals generated.")
        return self.signals

    # --- [Optional] Add similar methods for other strategies --- #
    # def run_average_volatility(...):
    #    self._generate_bars()
    #    # ... calculate signals using generate_average_volatility_signals ...
    #    self.signals = ...
    #    return self.signals

    def run_backtest(self):
        """Runs the backtest simulation based on the generated signals and bars."""
        if self.signals is None or self.bars is None:
            raise RuntimeError("Signals and bars must be generated before running the backtest. Call a strategy method first (e.g., run_bollinger_bands).")

        if 'close' not in self.bars.columns:
             raise RuntimeError("Bars DataFrame is missing 'close' column required for backtest.")

        # Align signals and bars - crucial if strategy generated signals on a subset
        signals = self.signals.reindex(self.bars.index).fillna(0)
        prices = self.bars['close']

        # Initialize portfolio DataFrame
        self.portfolio = pd.DataFrame(index=self.bars.index)
        self.portfolio['signal'] = signals
        self.portfolio['price'] = prices
        self.portfolio['holdings'] = 0.0 # Value of stock held
        self.portfolio['cash'] = self.initial_cash
        self.portfolio['position'] = 0 # Number of shares held
        self.portfolio['commission'] = 0.0

        self.trades = [] # Reset trades list for this run

        print(f"Running backtest simulation on {self.bar_type} bars...")

        position = 0 # Current number of shares held
        cash = self.initial_cash

        for i, timestamp in enumerate(self.portfolio.index):
            signal = self.portfolio.loc[timestamp, 'signal']
            price = self.portfolio.loc[timestamp, 'price']
            commission_cost = 0.0

            # --- Trading Logic --- #
            # Sell signal and currently holding shares
            if signal == -1 and position > 0:
                shares_to_sell = position # Sell all current holdings
                cash += shares_to_sell * price
                commission_cost = self.commission_per_trade
                cash -= commission_cost
                self.trades.append({
                    'timestamp': timestamp,
                    'type': 'SELL',
                    'shares': shares_to_sell,
                    'price': price,
                    'commission': commission_cost
                })
                position = 0 # Reset position

            # Buy signal and currently flat (no shares)
            elif signal == 1 and position == 0:
                # Simple allocation: use 95% of available cash
                # More sophisticated sizing could be added here
                cash_to_invest = cash * 0.95
                shares_to_buy = int(cash_to_invest / price) # Whole shares only

                if shares_to_buy > 0:
                    cost = shares_to_buy * price
                    commission_cost = self.commission_per_trade
                    if cash >= cost + commission_cost:
                        cash -= (cost + commission_cost)
                        position = shares_to_buy
                        self.trades.append({
                            'timestamp': timestamp,
                            'type': 'BUY',
                            'shares': shares_to_buy,
                            'price': price,
                            'commission': commission_cost
                        })
                    else:
                        # Not enough cash for the buy + commission
                        commission_cost = 0.0 # No trade happened
                        pass

            # Update portfolio values for the current timestamp
            self.portfolio.loc[timestamp, 'position'] = position
            self.portfolio.loc[timestamp, 'holdings'] = position * price
            self.portfolio.loc[timestamp, 'cash'] = cash
            self.portfolio.loc[timestamp, 'commission'] = commission_cost

        # Calculate total portfolio value
        self.portfolio['total'] = self.portfolio['holdings'] + self.portfolio['cash']
        self.portfolio['returns'] = self.portfolio['total'].pct_change().fillna(0)

        print("Backtest simulation finished.")
        self._calculate_performance_metrics()

    def _calculate_performance_metrics(self):
        """Calculates basic performance metrics after running the backtest."""
        if self.portfolio is None or self.portfolio.empty:
            print("Portfolio not generated. Run backtest first.")
            return

        total_return = (self.portfolio['total'].iloc[-1] / self.initial_cash - 1) * 100
        num_trades = len(self.trades)
        total_commission = sum(trade['commission'] for trade in self.trades)

        # --- More metrics could be added here (Sharpe Ratio, Max Drawdown, etc.) --- #
        # Requires calculating daily/periodic returns if not already done
        # Example: Calculate Drawdown
        rolling_max = self.portfolio['total'].cummax()
        daily_drawdown = self.portfolio['total']/rolling_max - 1.0
        max_drawdown = daily_drawdown.min() * 100

        print("\n--- Performance Metrics ---")
        print(f"Initial Portfolio Value: ${self.initial_cash:,.2f}")
        print(f"Final Portfolio Value:   ${self.portfolio['total'].iloc[-1]:,.2f}")
        print(f"Total Return:            {total_return:.2f}%")
        print(f"Maximum Drawdown:        {max_drawdown:.2f}%")
        print(f"Number of Trades:        {num_trades}")
        print(f"Total Commission Paid:  ${total_commission:,.2f}")
        print("---------------------------\n")


    def plot_results(self):
        """Plots the backtest results: portfolio value and trade signals."""
        if self.portfolio is None or self.bars is None:
            print("Portfolio or bars not available. Run strategy and backtest first.")
            return

        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), sharex=True)
        fig.suptitle(f'Backtest Results ({self.bar_type.capitalize()} Bars)')

        # --- Plot 1: Portfolio Value --- #
        ax1.plot(self.portfolio.index, self.portfolio['total'], label='Portfolio Value', color='blue')
        ax1.set_ylabel('Portfolio Value ($)')
        ax1.set_title('Portfolio Performance')
        ax1.grid(True)
        ax1.legend()

        # --- Plot 2: Price and Trades --- #
        # Use generated bars for price plotting
        plot_prices = self.bars['close'].reindex(self.portfolio.index)
        ax2.plot(self.portfolio.index, plot_prices, label='Close Price', color='black', alpha=0.7)
        ax2.set_ylabel('Price')
        ax2.set_title('Price and Trades')
        ax2.grid(True)

        # Plot Buy signals
        buy_signals = self.portfolio[self.portfolio['signal'] == 1]
        if not buy_signals.empty:
            ax2.plot(buy_signals.index, plot_prices.loc[buy_signals.index],
                     '^', markersize=8, color='g', label='Buy Signal', alpha=0.9)

        # Plot Sell signals
        sell_signals = self.portfolio[self.portfolio['signal'] == -1]
        if not sell_signals.empty:
            ax2.plot(sell_signals.index, plot_prices.loc[sell_signals.index],
                     'v', markersize=8, color='r', label='Sell Signal', alpha=0.9)

        ax2.legend()

        # Improve x-axis formatting for dates/times
        fig.autofmt_xdate()
        ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M')) # Adjust format as needed
        plt.xlabel('Timestamp')
        plt.tight_layout(rect=[0, 0.03, 1, 0.96]) # Adjust layout to prevent title overlap
        plt.show()


# --- Example Usage (Illustrative - place in a separate script or notebook cell) --- #
if __name__ == '__main__':
    # 1. Load your raw data (e.g., tick data or high-frequency bars)
    # Ensure it has a DatetimeIndex and required columns ('Close', 'Volume', etc.)
    # data_raw = pd.read_csv('your_data.csv', index_col='timestamp', parse_dates=True)
    data_raw = yf.download('AAPL', period='1mo', interval='1m') # Example using yfinance

    # --- Using Volume Bars --- #
    print("\n--- Backtesting with Volume Bars ---")
    # Option 1: Calculate threshold automatically
    backtester_vol = SimpleBacktester(data_raw, initial_cash=100000, commission_per_trade=1.0,
                                     bar_type='volume', target_bars_per_day=50)
    # Option 2: Provide specific threshold
    # backtester_vol = SimpleBacktester(data_raw, initial_cash=100000, commission_per_trade=1.0,
    #                                 bar_type='volume', volume_threshold=500000)
    try:
        backtester_vol.run_bollinger_bands(window=20, num_std=2.0)
        backtester_vol.run_backtest()
        backtester_vol.plot_results()
    except Exception as e:
        print(f"Volume bar backtest failed: {e}")

    # --- Using Time Bars --- #
    # print("\n--- Backtesting with Time Bars ---")
    # # Assume data_raw is already at the desired time frequency (e.g., 1 hour)
    # backtester_time = SimpleBacktester(data_raw, initial_cash=100000, commission_per_trade=1.0,
    #                                  bar_type='time')
    # try:
    #     backtester_time.run_bollinger_bands(window=20, num_std=2.0)
    #     backtester_time.run_backtest()
    #     backtester_time.plot_results()
    # except Exception as e:
    #     print(f"Time bar backtest failed: {e}")
